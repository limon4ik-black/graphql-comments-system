package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"

	"github.com/limon4ik-black/graphql-comments-system.git/graph/model"
	"github.com/limon4ik-black/graphql-comments-system.git/internal/domain"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, author string) (*model.Post, error) {
	r.Log.Info("CreatePost called", "title", title)
	post := &domain.Post{
		Title:   title,
		Content: content,
		Author:  author,
	}

	err := r.PostService.Create(ctx, post)
	if err != nil {
		return nil, err
	}
	r.Log.Info("CreatePost complete", "postId", post.ID)
	return &model.Post{
		ID:              post.ID,
		Title:           post.Title,
		Content:         post.Content,
		Author:          post.Author,
		CommentsAllowed: post.Flag,
	}, nil
}

// ToggleComments is the resolver for the toggleComments field.
func (r *mutationResolver) ToggleComments(ctx context.Context, postID string, allowed bool) (*model.Post, error) {
	r.Log.Info("ToggleComments called", "postID", postID)
	if err := r.PostService.SetFlag(ctx, postID, allowed); err != nil {
		return nil, err
	}

	post, err := r.PostService.Get(ctx, postID)
	if err != nil {
		return nil, err
	}

	return mapPostDomainToModel(post), nil
}

func mapPostDomainToModel(p *domain.Post) *model.Post {
	if p == nil {
		return nil
	}
	return &model.Post{
		ID:              p.ID,
		Title:           p.Title,
		Content:         p.Content,
		Author:          p.Author,
		CommentsAllowed: p.Flag,
		Comments:        mapCommentsDomainToModel(p.Comments),
	}
}

func mapCommentDomainToModel(c *domain.Comment) *model.Comment {
	if c == nil {
		return nil
	}
	return &model.Comment{
		ID:       c.ID,
		PostID:   c.PostID,
		ParentID: c.ParentID,
		Author:   c.Author,
		Text:     c.Text,
		Children: mapCommentsDomainToModel(c.Children),
	}
}

func mapCommentsDomainToModel(comments []*domain.Comment) []*model.Comment {
	res := make([]*model.Comment, 0, len(comments))
	for _, c := range comments {
		res = append(res, mapCommentDomainToModel(c))
	}
	return res
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, parentID *string, text string) (*model.Comment, error) {
	r.Log.Info("AddComment called", "postID", postID)
	comment := &domain.Comment{
		PostID:   postID,
		ParentID: parentID,
		Text:     text,
		Author:   "anonymous",
	}

	err := r.CommentService.Create(ctx, comment)
	if err != nil {
		return nil, err
	}

	modelComment := &model.Comment{
		ID:       comment.ID,
		PostID:   comment.PostID,
		ParentID: comment.ParentID,
		Author:   comment.Author,
		Text:     comment.Text,
	}

	r.Mu.Lock()
	subs := r.CommentSubscribers[postID]
	for _, ch := range subs {
		select {
		case ch <- modelComment:
		default:
		}
	}
	r.Mu.Unlock()
	r.Log.Info("Notifying subscribers", "postID", postID, "count", len(subs))

	return modelComment, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	r.Log.Info("Posts called")
	posts, err := r.PostService.GetList(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.Post
	for _, post := range posts {
		result = append(result, mapPostToModel(post))
	}

	return result, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	r.Log.Info("Post called", "postID", id) //postId
	post, err := r.PostService.Get(ctx, id)
	if err != nil {
		return nil, err
	}

	return mapPostToModel(post), nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	r.Log.Info("CommentAdded called", "postID", postID)
	ch := make(chan *model.Comment, 10)

	r.Mu.Lock()
	r.CommentSubscribers[postID] = append(r.CommentSubscribers[postID], ch)
	r.Log.Info("Added subscription", "postID", postID, "total", len(r.CommentSubscribers[postID]))
	r.Mu.Unlock()

	go func() {
		<-ctx.Done()
		r.Log.Info("Subscription cancelled", "postID", postID)
		r.Mu.Lock()
		subs := r.CommentSubscribers[postID]
		for i, sub := range subs {
			if sub == ch {
				r.CommentSubscribers[postID] = append(subs[:i], subs[i+1:]...)
				break
			}
		}
		r.Log.Info("Subscription removed", "postID", postID, "total", len(r.CommentSubscribers[postID]))
		r.Mu.Unlock()
	}()

	return ch, nil
}

func mapPostToModel(post *domain.Post) *model.Post {
	var comments []*model.Comment
	for _, c := range post.Comments {
		comments = append(comments, mapCommentToModel(c))
	}

	return &model.Post{
		ID:              post.ID,
		Title:           post.Title,
		Content:         post.Content,
		Author:          post.Author,
		CommentsAllowed: post.Flag,
		Comments:        comments,
	}
}

func mapCommentToModel(c *domain.Comment) *model.Comment {
	var children []*model.Comment
	for _, child := range c.Children {
		children = append(children, mapCommentToModel(child))
	}

	return &model.Comment{
		ID:       c.ID,
		PostID:   c.PostID,
		ParentID: c.ParentID,
		Author:   c.Author,
		Text:     c.Text,
		Children: children,
	}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
